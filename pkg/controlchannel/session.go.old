package controlchannel

import (
	"encoding/json"
	"net"
	"time"

	log "github.com/Sirupsen/logrus"
	"github.com/gorilla/websocket"
)

type session struct {
	//conn         *websocket.Conn
	conn         net.Conn
	ctrl         *sessionController
	startedAt    time.Time
	registeredCh chan bool
	quitCh       chan bool
	nextFrameCh  chan bool
	registered   bool
}

func newSession(conn net.Conn, ctrl *sessionController) *session {
	return &session{
		conn:         conn,
		ctrl:         ctrl,
		startedAt:    time.Now(),
		registeredCh: make(chan bool),
		nextFrameCh:  make(chan bool),
		quitCh:       make(chan bool),
	}
}

func (sess *session) close() {
	sess.ctrl.unregisterSession(sess)

	if sess.conn != nil {
		sess.conn.Close()
	}

	log.WithFields(log.Fields{"remoteAddr": sess.conn.RemoteAddr()}).
		Info("Control channel session closed")
}

func (sess *session) handleRequest(req []interface{}, encoder *json.Encoder) error {
	messageType := int(req[0].(float64))
	switch messageType {
	case messageTypeHello:
		{
			if len(req) < 2 || req[1].(string) == "" {
				writeAbortMessage(encoder, errInvalidRealm, "No or invalid realm given")
				return errInvalidRealm
			}

			_, err := sess.ctrl.registerSession(req[1].(string))
			if err != nil {
				// TODO: Ensure that we get only errors with valid reason! Eg. tech. exception, etc.
				writeAbortMessage(encoder, err, "Add a good error message...")
				return err
			}

			// Add websocket connection to map with associated session ID
			//sess.ctrl.sessions[sess.conn] = sessionID

			if err := writeWelcomeMessage(encoder, 1234, welcomeMessageDetails{
				SessionTimeout: 30,
				PingInterval:   28,
				PongTimeout:    16,
				EventsTopic:    "devices::events"}); err != nil {
				log.Error("Failed to write message:", err)
				return err
			}

			// Quit the registration timeout routine
			sess.register()
		}
		break
	}
	return nil
}

func (sess *session) listenAndServe() {
	/*
		for {
			mt, payload, err := sess.conn.ReadMessage()
			if err != nil {
				log.Error("Failed to read message:", err)
				return
			}

			log.WithFields(log.Fields{"mt": mt, "payload": string(payload)}).Debug("Received message")

			var message []interface{}
			if err := json.Unmarshal(payload, &message); err != nil {
				log.Error("Failed to unmarshal message:", err)
				return
			}

			messageType := message[0].(float64)
			switch int(messageType) {
			case messageTypeHello:
				{
					if len(message) < 2 || message[1].(string) == "" {
						writeAbortMessage(sess.conn, errInvalidRealm, "No or invalid realm given")
						return
					}

					sessionID, err := sess.ctrl.registerSession(sess.conn, message[1].(string))
					if err != nil {
						// TODO: Ensure that we get only errors with valid reason! Eg. tech. exception, etc.
						writeAbortMessage(sess.conn, err, "Add a good error message...")
						return
					}

					// Add websocket connection to map with associated session ID
					sess.ctrl.sessions[sess.conn] = sessionID

					if err := writeWelcomeMessage(sess.conn, 1234, welcomeMessageDetails{
						SessionTimeout: 30,
						PingInterval:   28,
						PongTimeout:    16,
						EventsTopic:    "devices::events"}); err != nil {
						log.Error("Failed to write message:", err)
						return
					}

					// Quit the registration timeout routine
					sess.register()
				}
				break
			case messageTypePing, messageTypePublish:
				{
					exists, err := sess.ctrl.existsSession(sess.ctrl.sessions[sess.conn])
					if err != nil {
						// TODO: Ensure that we get only errors with valid reason! Eg. tech. exception, etc.
						writeAbortMessage(sess.conn, err, "Add a good error message...")
						return
					}

					if !exists {
						// TODO: Ensure that we get only errors with valid reason! Eg. tech. exception, etc.
						writeAbortMessage(sess.conn, errInvalidSession, "Add a good error message...")
						return
					}

					if err := sess.handleIncomingMessage(sess.conn, message); err != nil {
						log.Error("Failed to handle incoming message:", err)
						return
					}

					// Update the session, otherwise it expires
					sess.ctrl.updateSession(sess.ctrl.sessions[sess.conn], 1, 1)
				}
				break
			default:
				{

				}
				break
			}
		}*/
}

func (sess *session) handleIncomingMessage(c *websocket.Conn, message []interface{}) error {
	/*messageType := int(message[0].(float64))
	switch messageType {
	case messageTypePing:
		{
			if err := writePongMessage(c, pongMessageDetails{}); err != nil {
				return err
			}
		}
		break
		case messageTypePublish:
		{
			requestID := int(message[1].(float64))
			topic := message[2].(string)
			//args := message[3].(publishMessageDetails)
			//log.Debug("args=", args)

			body, err := json.Marshal(message[3])
			if err != nil {
				log.Error("Failed to marshal body:", err)
				return err
			}
			log.Debug("body=", string(body))

			publicationID, err := sess.ctrl.publishMessageToAMQP(topic, string(body))
			if err != nil {
				writeErrorMessage(c, messageType, requestID,
					"ERR_UNKNOWN_EXCEPTION", errorMessageDetails{Error: err.Error()})

				// TODO: check if this okay? How to handle such errors in future?
				return nil
			}

			if err := writePublishedMessage(c, requestID, publicationID); err != nil {
				return err
			}
		}
	}*/

	return nil
}

func (sess *session) register() {
	sess.registered = true
	sess.registeredCh <- true
}

func writeAbortMessage(encoder *json.Encoder, reason error, details string) error {
	var msg []interface{}
	msg = append(msg, messageTypeAbort)
	msg = append(msg, reason.Error())
	msg = append(msg, abortMessageDetails{Message: details})

	log.WithFields(log.Fields{"msg": msg}).Debug("Sending abort message")

	return encoder.Encode(msg)
}

func writeWelcomeMessage(encoder *json.Encoder, sessionID int, details interface{}) error {
	var msg []interface{}
	msg = append(msg, messageTypeWelcome)
	msg = append(msg, sessionID)
	msg = append(msg, details)

	log.WithFields(log.Fields{"msg": msg}).Debug("Sending welcome message")
	return encoder.Encode(msg)
}

func writePongMessage(encoder *json.Encoder, details interface{}) error {
	var msg []interface{}
	msg = append(msg, messageTypePong)
	msg = append(msg, details)

	log.WithFields(log.Fields{"msg": msg}).Debug("Sending pong message")
	return encoder.Encode(msg)
}

func writeErrorMessage(encoder *json.Encoder, messageType, requestID int, err string, details interface{}) error {
	var msg []interface{}
	msg = append(msg, messageTypeError)
	msg = append(msg, messageType)
	msg = append(msg, requestID)
	msg = append(msg, err)
	msg = append(msg, details)

	log.WithFields(log.Fields{"msg": msg}).Debug("Sending error message")
	return encoder.Encode(msg)
}

func writePublishedMessage(encoder *json.Encoder, requestID, publicationID int) error {
	var msg []interface{}
	msg = append(msg, messageTypePublished)
	msg = append(msg, requestID)
	msg = append(msg, publicationID)

	log.WithFields(log.Fields{"msg": msg}).Debug("Sending published message")
	return encoder.Encode(msg)
}
