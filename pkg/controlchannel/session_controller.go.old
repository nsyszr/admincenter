package controlchannel

import (
	"encoding/json"
	"net/http"
	"time"

	log "github.com/Sirupsen/logrus"
	"github.com/gobwas/ws"
	"github.com/gobwas/ws/wsutil"

	"github.com/go-redis/redis"
	"github.com/gorilla/websocket"
)

// sessionController handles the websocket client sessions
type sessionController struct {
	// TODO: Abstract db to interface
	db       *redis.Client
	sessions map[*websocket.Conn]int32
	// sessions map[string]*session
}

// newSessionController creates a new session controller instance
func newSessionController(db *redis.Client) *sessionController {
	return &sessionController{
		db:       db,
		sessions: make(map[*websocket.Conn]int32),
		// sessions:    make(map[string]*session),
	}
}

func (ctrl *sessionController) startSession(w http.ResponseWriter, r *http.Request) error {
	// Upgrade to a WebSocket connection
	conn, _, _, err := ws.UpgradeHTTP(r, w)
	if err != nil {
		log.WithFields(log.Fields{"remoteAddr": conn.RemoteAddr()}).
			Error("Failed to upgrade HTTP websocket:", err)
		return err
	}

	// TODO: Create a unique session ID, even if the session is not registered.
	//       This is interessting for Prometheus statistics! Add expires at
	//       to the session Redis key. If the session wont be registered, it
	//       disappears from the Prometheus statistics.
	// NOTES: Rethink that idea! Create seperate stats for initiated connections,
	//        for dropped onces, etc. A session should be only established
	//		  if both parties agree to each other.

	sess := newSession(conn, ctrl)

	log.WithFields(log.Fields{"remoteAddr": conn.RemoteAddr()}).
		Info("Control channel session started")

	// Start a background timer to invalidate session if not registered within
	// a specified time period.
	go func() {
		log.WithFields(log.Fields{"remoteAddr": sess.conn.RemoteAddr()}).
			Debug("Registration timeout routine started")
		for {
			select {
			case <-sess.registeredCh:
				log.WithFields(log.Fields{"remoteAddr": sess.conn.RemoteAddr()}).
					Debug("Registration timeout routine stopped")
				return
			case <-sess.quitCh:
				log.WithFields(log.Fields{"remoteAddr": sess.conn.RemoteAddr()}).
					Debug("Registration timeout routine quitted")
				return
			case <-time.After(60 * time.Second): // TODO: get timeout from config
				log.WithFields(log.Fields{"remoteAddr": sess.conn.RemoteAddr()}).
					Debug("Registration timeout routine expired")
				// Send session quit signal
				sess.quitCh <- true
				return
			}
		}
	}()

	// Start listening for next frames
	go func() {
		defer sess.close()

		var (
			r       = wsutil.NewReader(conn, ws.StateServerSide)
			w       = wsutil.NewWriter(conn, ws.StateServerSide, ws.OpText)
			decoder = json.NewDecoder(r)
			encoder = json.NewEncoder(w)
		)

		for {
			log.Debug("Next Frame Loop")

			if _, err := r.NextFrame(); err != nil {
				log.WithFields(log.Fields{"remoteAddr": conn.RemoteAddr()}).
					Error("Failed to read the next frame:", err)
				return
			}

			var req []interface{}
			if err := decoder.Decode(&req); err != nil {
				log.WithFields(log.Fields{"remoteAddr": conn.RemoteAddr()}).
					Error("Failed to decode request:", err)
				return
			}

			log.WithFields(log.Fields{"remoteAddr": conn.RemoteAddr()}).
				Debugf("Received message: %v", req)

			sess.handleRequest(req, encoder)

			if err = w.Flush(); err != nil {
				log.WithFields(log.Fields{"remoteAddr": conn.RemoteAddr()}).
					Error("Failed to flush response:", err)
				return
			}
		}
	}()

	return nil
}
